[{"fileName":"1._Two_Sum","codeText":"public class Solution {\n    private int binarySearch(int[] nums, int val){\n        int l=0;int r=nums.length-1;\n        int mid;\n        while(l<=r){\n            mid=(l+r)/2;\n            if(nums[mid]==val)return mid;\n            if(nums[mid]>val)r=mid-1;\n            else l=mid+1;\n        }\n        return -1;\n    }\n    private int listSearch(int[] nums,int val){\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val)return i;\n        }\n        return -1;\n    }\n    public int[] twoSum(int[] nums, int target) {\n        int [] res=new int[2];\n        //count for twice\n        if(target%2==0){\n            int count=0;\n            int val=target/2;\n            for(int i=0;i<nums.length;i++){\n                if(nums[i]==val){\n                    res[count++]=i;\n                    if(count>=2)return res;\n                }\n            }\n        }\n        //no repeat will happen\n        int[] nums2=nums.clone();\n        Arrays.sort(nums2);\n        //now let's do it with binary search\n        for(int i=0;i<nums.length;i++){\n            int t=binarySearch(nums2,target-nums[i]);\n            if(t>0 && nums[i]!=nums2[t]){\n                res[0]=i;\n                res[1]=listSearch(nums,nums2[t]);\n                return res;\n            }\n        }\n        return res;\n        \n    }\n}\n","usedLang":"Java"},{"fileName":"2._Add_Two_Numbers","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        return addHelper(l1,l2,0);\n    }\n    \n    private ListNode addHelper(ListNode l1, ListNode l2,int c){\n        if(l1==null && l2==null){ \n            if(c>0)return new ListNode(c);\n            return null;\n        }\n        int v1=0;\n        ListNode t1=null;\n        ListNode t2=null;\n        int v2=0;\n        if(l1!=null){\n            v1=l1.val;t1=l1.next;\n        }\n        if(l2!=null){\n            v2=l2.val;t2=l2.next;\n        }\n        int v=v1+v2+c;\n        c=v/10;\n        v%=10;\n        ListNode res=new ListNode(v);\n        res.next=addHelper(t1,t2,c);\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"3._Longest_Substring_Without_Repeating_Characters","codeText":"public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int p1,p2;\n        if(s.length()==0)return 0;\n        Map<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int len=0;\n        int max=0;\n        for(p1=0,p2=0;p1<s.length();p1++){\n            char ch=s.charAt(p1);\n            if(map.containsKey((int)ch)){\n                int last=map.get((int)ch);\n                if(last>p2)p2=last;\n                len=p1-p2;\n                map.put((int)ch,p1);\n            }else{\n                map.put((int)ch,p1);\n                len++;\n            }\n            if(len>max)max=len;\n        }\n        return max;\n    }\n}\n","usedLang":"Java"},{"fileName":"6._ZigZag_Conversion","codeText":"public class Solution {\n    public String convert(String s, int numRows) {\n        if(numRows<=1)return s;\n        StringBuilder[] rows=new StringBuilder[numRows];\n        for(int i=0;i<numRows;i++) rows[i]=new StringBuilder();\n        int row=0;\n        boolean down=true;\n        for(int i=0;i<s.length();i++){\n            rows[row].append(s.charAt(i));\n            if(down)row++;\n            else row--;\n            if(row==numRows){\n                down=false;\n                row=numRows-2;\n            }\n            if(row==-1){\n                down=true;\n                row=1;\n            }\n        }\n        StringBuilder res=new StringBuilder();\n        for(StringBuilder strb:rows){\n            res.append(strb);\n        }\n        return res.toString();\n    }\n}\n","usedLang":"Java"},{"fileName":"7._Reverse_Integer","codeText":"public class Solution {\n    public int reverse(int tx) {\n        long x=tx;\n        if(tx<0) x=-tx;\n        long res=0;\n        while(x>0){\n            res=res*10+x%10;\n            x/=10;\n            if(res>Integer.MAX_VALUE)return 0;\n        }\n        if(tx<0) return (int)-res;\n        return (int)res;\n    }\n}\n","usedLang":"Java"},{"fileName":"8._String_to_Integer_(atoi)","codeText":"public class Solution {\n    public int myAtoi(String str) {\n        str=str.trim();\n        if(str.length()==0){\n            return 0;\n        }\n        //get all digits\n        long num=0;\n        int i=0;\n        boolean positive=true;\n        //check for signal\n        if(str.charAt(0)=='-'){\n            i=1;positive=false;\n        }else if(str.charAt(0)=='+'){\n            i=1;positive=true;\n        }\n        for(;i<str.length();i++){\n            if(!Character.isDigit(str.charAt(i))){\n                //error!\n                break;\n            }\n            num=num*10+(str.charAt(i)-'0');\n            if(i>11)break;\n        }\n        if(!positive)num=-num;\n        if(num>Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if(num<Integer.MIN_VALUE) return Integer.MIN_VALUE;\n        return (int)num;\n    }\n}\n","usedLang":"Java"},{"fileName":"9._Palindrome_Number","codeText":"public class Solution {\n    public boolean isPalindrome(int x) {\n        if(x<0){\n            return false;\n        }\n        if(x<10){\n            return true;\n        }\n        long out=0;\n        int tx=x;\n        while(tx>0){\n            out+=tx%10;\n            tx/=10;\n            if(tx>0){\n                out*=10;\n            }\n        }\n        if(out>Integer.MAX_VALUE){\n            return false;\n        }\n        if((int)out==x){\n            return true;\n        }\n        return false;\n    }\n  \n}\n","usedLang":"Java"},{"fileName":"10._Regular_Expression_Matching","codeText":"public class Solution {\n    public boolean isMatch(String s, String p) {\n        if(p.length()==0){\n           return s.length()==0;\n        }\n        if(p.length()>1 && p.charAt(1)=='*'){\n            if(isMatch(s, p.substring(2)))return true;\n        }\n        if(s.length()==0)return false;\n        //from left to match a char, and then match for the rest\n        char ch=s.charAt(0);\n        boolean res=false;\n        if(p.charAt(0)==ch ||p.charAt(0)=='.'){\n            //use it\n            if(isMatch(s.substring(1), p.substring(1)))return true;\n            if(p.length()>1 && p.charAt(1)=='*'){\n                if(isMatch(s.substring(1),p))return true;\n            }\n        }\n        \n        //if nothing can match, return false\n        return false;\n    }\n}\n","usedLang":"Java"},{"fileName":"12._Integer_to_Roman","codeText":"public class Solution {\n    private String[] DigitPattern={\"\",\"A\",\"AA\",\"AAA\",\"AB\",\"B\",\"BA\",\"BAA\",\"BAAA\",\"AJ\",\"J\"};\n    private String[] ShiftRules={\"ABJ\",\"IVX\",\"XLC\",\"CDM\",\"MKK\"};\n    public String intToRoman(int num) {\n        String res=\"\";\n        //start from lowest digit\n        int which=0;\n        while(num>0){\n            int d=num%10;\n            num/=10;which++;\n            if(d==0)continue;\n            String currD=DigitPattern[d];\n            for(int i=0;i<3;i++){\n                currD=currD.replace(ShiftRules[0].charAt(i),ShiftRules[which].charAt(i));\n            }\n            res=currD+res;\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"13._Roman_to_Integer","codeText":"public class Solution {\n    String base=\"IVXLCDM\";\n    public int romanToInt(String s) {\n        if(s.length()==0)return 0;\n        int res=0;\n        int[] values={1,5,10,50,100,500,1000,0};\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        map.put('I',0);map.put('V',1);map.put('X',2);map.put('L',3);map.put('C',4);map.put('D',5);map.put('M',6);\n        map.put(' ',7);\n        char last=' ';\n        int count=0;\n        boolean valuedLast=false;\n        for(char ch:s.toCharArray()){\n            valuedLast=false;\n            if(last==' '){last=ch;count=1;continue;}\n            if(last==ch){count++;if(count>3)return -1;}\n            else if(map.get(last)<map.get(ch) && count==1){\n                res+=values[map.get(ch)]-values[map.get(last)];\n                last=' ';\n                valuedLast=true;\n            }\n            else if(map.get(ch)<map.get(last)){\n                res+=values[map.get(last)]*count;\n                last=ch;count=1;\n            }else{\n                return -1;\n            }\n        }\n        if(!valuedLast)res+=values[map.get(last)]*count;\n        return res;\n        \n        \n    }\n}\n","usedLang":"Java"},{"fileName":"14._Longest_Common_Prefix","codeText":"public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if(strs.length==0){\n            return \"\";\n        }\n        String prefix=strs[0];\n        int max=prefix.length();\n        for(String str:strs){\n            for(int i=0;i<=max;i++){\n                if(i==prefix.length() || i==str.length() || str.charAt(i)!=prefix.charAt(i)){\n                    max=i;\n                    if(max<0){\n                        return \"\";\n                    }\n                    break;\n                }\n            }\n        }\n        return prefix.substring(0,max);\n    }\n}\n","usedLang":"Java"},{"fileName":"15._3Sum","codeText":"public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        int[][] numIs=new int[nums.length][2];\n        for(int i=0;i<numIs.length;i++){\n            numIs[i][0]=nums[i];numIs[i][1]=i;\n        }\n        Arrays.sort(numIs,new Comparator<int[]>(){public int compare(int[]a,int[]b) {return a[0]-b[0];}});\n        HashMap<Integer,int[]> inlist=new HashMap<Integer,int[]>();\n        for(int i=0;i<numIs.length;i++){\n            if(inlist.containsKey(numIs[i][0])){inlist.get(numIs[i][0])[1]=i;}\n            else{int[] t=new int[2];t[0]=i;t[1]=i;inlist.put(numIs[i][0],t);}\n        }\n        List<List<Integer>> res=new ArrayList<List<Integer>>();\n        for(int i=0;i<numIs.length;){\n            for(int j=i+1;j<nums.length;){\n                int sum=-(numIs[i][0]+numIs[j][0]);\n                if(inlist.containsKey(sum)){\n                    int k=inlist.get(sum)[1];\n                    if(k>j)res.add(genList(numIs[i][0],numIs[j][0],numIs[k][0]));\n                }\n                //update j\n                int currJ=numIs[j][0];\n                while(j<numIs.length && numIs[j][0]==currJ)j++;\n            }\n            int currI=numIs[i][0];\n            while(i<numIs.length && numIs[i][0]==currI)i++;\n            \n        }\n        return res;\n    }\n    private List<Integer> genList(int i,int j,int k){\n        List<Integer> list=new ArrayList<Integer>();\n        list.add(i);list.add(j);list.add(k);\n        return list;\n    }\n}\n","usedLang":"Java"},{"fileName":"17._Letter_Combinations_of_a_Phone_Number","codeText":"public class Solution {\n    String[] letters={\" \",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n    public List<String> letterCombinations(String digits) {\n        List<String> res=new ArrayList<String>();\n        if(digits.length()==0)return res;\n        oneDigitHelper(\"\",0,digits,res);\n        return res;\n    }\n    private void oneDigitHelper(String curr,int index,String digits,List<String> res){\n        if(index==digits.length()){\n            res.add(curr);\n            return;\n        }\n        String candidates=letters[digits.charAt(index)-'0'];\n        for(char ch:candidates.toCharArray()){\n            oneDigitHelper(curr+ch,index+1,digits, res);\n        }\n    }\n    \n}\n","usedLang":"Java"},{"fileName":"18._4Sum","codeText":"public class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        Map<Integer, List<List<Integer>>> map=new HashMap<Integer, List<List<Integer>>>();\n        List<List<Integer>> res=new  ArrayList<List<Integer>>();\n        //first make all numbers into 2 numbers\n        //make the hashmap for future use\n        for(int i=0;i<nums.length-1;i++){\n            for(int j=i+1;j<nums.length;j++){\n                if(map.containsKey(nums[i]+nums[j])){\n                    List<List<Integer>> list=map.get(nums[i]+nums[j]);\n                    ArrayList<Integer> twoNum=new ArrayList<Integer>();\n                    twoNum.add(i);twoNum.add(j);\n                    list.add(twoNum);\n                }else{\n                    ArrayList<Integer> twoNum=new ArrayList<Integer>();\n                    twoNum.add(i);twoNum.add(j);\n                    List<List<Integer>> list=new ArrayList<List<Integer>>();\n                    list.add(twoNum);\n                    map.put(nums[i]+nums[j],list);\n                }\n            }\n        }\n        HashSet<String> sols=new HashSet<String>();\n        //now start finding the answers\n        for(int i=0;i<nums.length-1;i++){\n            for(int j=i+1;j<nums.length;j++){\n                int sum=nums[i]+nums[j];\n                int dif=target-sum;\n                if(map.containsKey(dif)){\n                    //possible answers in here\n                    List<List<Integer>> list=map.get(dif);\n                    for(List<Integer> curr:list){\n                        if(curr.get(0)!=i && curr.get(0)!=j && curr.get(1)!=i && curr.get(1)!=j){\n                            List<Integer> sol=new ArrayList<Integer>();\n                            sol.add(nums[i]);\n                            sol.add(nums[j]);\n                            sol.add(nums[curr.get(0)]);\n                            sol.add(nums[curr.get(1)]);\n                            Collections.sort(sol);\n                            String s=\"\";\n                            for(int ii:sol){\n                                s=s+ii+\" \";\n                            }\n                            if(!sols.contains(s)){\n                                res.add(sol);\n                                sols.add(s);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"19._Remove_Nth_Node_From_End_of_List","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        if(head==null || n==0)return head;\n        ListNode fast=head;\n        ListNode slow=head;\n        ListNode pslow=null;\n        for(int i=0;i<n;i++){\n            fast=fast.next;\n        }\n        if(fast==null)return head.next;\n        while(fast!=null){\n           fast=fast.next;\n           pslow=slow;\n           slow=slow.next;\n        }\n        pslow.next=slow.next;\n        \n        return head;\n        \n    }\n\n}\n","usedLang":"Java"},{"fileName":"20._Valid_Parentheses","codeText":"public class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack=new Stack<Character>();\n        for(char ch:s.toCharArray()){\n            if(isOpen(ch))stack.push(ch);\n            else if(isClose(ch)){\n                if(stack.size()==0)return false;\n                char last=getClose(stack.pop());\n                if(last!=ch){\n                    return false;\n                }\n            }\n        }\n        \n        return stack.size()==0;\n    }\n\n    private boolean isOpen(char ch){\n        return ch=='(' || ch=='[' || ch=='{';\n    }\n    private boolean isClose(char ch){\n        return ch==']' || ch=='}'|| ch==')';\n    }\n    private char getClose(char ch){\n        switch(ch){\n            case '(':return ')';\n            case '[':return ']';\n            case '{':return '}';\n        }\n        return ' ';\n    }\n}\n","usedLang":"Java"},{"fileName":"21._Merge_Two_Sorted_Lists","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if(l2==null)return l1;\n        if(l1==null)return l2;\n        ListNode head,tail,p1=l1,p2=l2;\n        if(l1.val<l2.val){\n            head=l1;p1=p1.next;tail=head;\n        }else{\n            head=l2;p2=p2.next;tail=head;\n        }\n        while(p1!=null && p2!=null){\n            if(p1.val<p2.val){\n                tail.next=p1;p1=p1.next;tail=tail.next;\n            }else{\n                tail.next=p2;p2=p2.next;tail=tail.next;\n            }\n        }\n        while(p1!=null){\n            tail.next=p1;p1=p1.next;tail=tail.next;\n        }\n        while(p2!=null){\n            tail.next=p2;p2=p2.next;tail=tail.next;\n        }\n        tail.next=null;\n        return head;\n        \n    }\n}\n","usedLang":"Java"},{"fileName":"22._Generate_Parentheses","codeText":"public class Solution {\n    ArrayList<String> res;\n    public List<String> generateParenthesis(int n) {\n        if(n==0)return null;\n        res=new ArrayList<String>();\n        ParenthesisHelper(\"\",n,n);\n        return res;\n    }\n    private void ParenthesisHelper(String str,int l,int r){\n        if(l==0 && r==0){\n            res.add(str);\n        }\n        if(l==r || l>0) {\n            ParenthesisHelper(str+'(',l-1,r);\n        }\n        if(l<r && r>0){\n            ParenthesisHelper(str+')',l,r-1);\n        }\n    }\n}\n","usedLang":"Java"},{"fileName":"23._Merge_k_Sorted_Lists","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public class IntFrom implements Comparable<IntFrom>{\n        public int val;\n        public int from;\n        public IntFrom(int v,int f){val=v;from=f;}\n        \n        public int compareTo(IntFrom o) {\n            // TODO Auto-generated method stub\n            \n            return val-o.val;\n        }\n    }\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode res=null;\n        ListNode last=null;\n        PriorityQueue<IntFrom> heap=new PriorityQueue<IntFrom>();\n        //init\n        for(int i=0;i<lists.length;i++){\n            if(lists[i]!=null){\n                IntFrom curr=new IntFrom(lists[i].val,i);\n                heap.add(curr);\n            }\n        }\n        //extract\n        while(heap.peek()!=null){\n            IntFrom curr=heap.poll();\n            ListNode ln=new ListNode(curr.val);\n            if(res==null){\n                res=ln;\n                last=ln;\n            }else{\n                last.next=ln;\n                last=last.next;\n            }\n            //add next one\n            lists[curr.from]=lists[curr.from].next;\n            if(lists[curr.from]!=null){\n                IntFrom temp=new IntFrom(lists[curr.from].val,curr.from);\n                heap.add(temp);\n            }\n            \n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"24._Swap_Nodes_in_Pairs","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head==null || head.next==null)return head;\n        ListNode a=head;\n        ListNode b=head.next;\n        ListNode next=swapPairs(b.next);\n        a.next=next;\n        b.next=a;\n        return b;\n    }\n}\n","usedLang":"Java"},{"fileName":"25._Reverse_Nodes_in_k-Group","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if(k<=1 || head ==null || head.next==null)return head;\n        //count for k elements\n        ListNode p=head;\n        int count=0;\n        while(p!=null){\n            count++;\n            if(count==k) break;\n            p=p.next;\n        }\n        if(count<k){return head;}\n        //run reverseKGroup for the 2nd part\n        ListNode p2=null;\n        p2=reverseKGroup(p.next,k);\n        //reverse the first part\n        p.next=null;\n        ListNode p1=reverseList(head);\n        return listCat(p1,p2);\n        //cat first and second part\n    }\n    //reverse a list and return the first one\n    private ListNode reverseList(ListNode head){\n        if(head==null || head.next==null)return head;\n        ListNode p=head.next;\n        head.next=null;\n        ListNode tmp;\n        while(p!=null){\n            tmp=p.next;\n            p.next=head;\n            head=p;\n            p=tmp;\n        }\n        return head;\n    }\n    private ListNode listCat(ListNode a,ListNode b){\n        if(a==null)return b;\n        ListNode p=a;\n        while(p.next!=null)p=p.next;\n        p.next=b;\n        return a;\n    }\n}\n","usedLang":"Java"},{"fileName":"26._Remove_Duplicates_from_Sorted_Array","codeText":"public class Solution {\n    \n    public int removeDuplicates(int[] nums) {\n        int plast=0;\n        if(nums.length==0){return 0;}\n        for(int i=1;i<nums.length;i++){\n            if(nums[i]!=nums[plast]){\n                plast++;\n                nums[plast]=nums[i];\n            }\n        }\n        return plast+1;\n    }\n}\n","usedLang":"Java"},{"fileName":"27._Remove_Element","codeText":"public class Solution {\n    public int removeElement(int[] nums, int val) {\n        int last=0;\n        int count=0;\n        if(nums.length==0)return 0;\n        boolean flag=true;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]!=val){\n                nums[last++]=nums[i];\n            }else{\n                count++;\n            }\n        }\n        return nums.length-count;\n    }\n}\n","usedLang":"Java"},{"fileName":"28._Implement_strStr()","codeText":"public class Solution {\n    public int strStr(String haystack, String needle) {\n        if(needle.length()>haystack.length())return -1;\n        if(needle.length()==0)return 0;\n        char[] hay=haystack.toCharArray();\n        char[] nee=needle.toCharArray();\n        for(int i=0;i<=hay.length-nee.length;i++){\n            int j;\n            for(j=0;j<nee.length;j++){\n                if(hay[i+j]!=nee[j]){\n                    j=-1; break;\n                }\n            }\n            if(j!=-1)return i;\n        }\n        return -1;\n        \n    }\n}\n","usedLang":"Java"},{"fileName":"29._Divide_Two_Integers","codeText":"public class Solution {\n    public int divide(int dividend, int divisor) {\n        if(divisor==0)return Integer.MAX_VALUE;\n        if(divisor==1)return dividend;\n        if(dividend==0)return 0;\n        return divideHelper((long)dividend,(long)divisor);\n    }\n    private int divideHelper(long dend,long dor){\n        if(dend<0) return -divideHelper(-dend,dor);\n        if(dor<0) return -divideHelper(dend,-dor);\n        if(dor==1 && dend>Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if(dor==1) return (int) dend;\n        if(dend<dor)return 0;\n        int from=64-Long.numberOfLeadingZeros(dend-1);\n        int res=0;\n        for(;from>=0 && dend>0;from--){\n            if(dend>=(dor<<from)){\n                res+=1<<from;\n                dend-=dor<<from;\n            }\n        }\n        return res;\n    }\n    \n}\n","usedLang":"Java"},{"fileName":"31._Next_Permutation","codeText":"public class Solution {\n    private void reverseArr(int[] nums, int l, int r){\n        while(l<r){\n            int t=nums[r];\n            nums[r]=nums[l];\n            nums[l]=t;\n            l++;r--;\n        }\n    }\n    public void nextPermutation(int[] nums) {\n        if(nums.length<=1)return;\n        int last=nums[nums.length-1];\n        for(int i=nums.length-2;i>=0;i--){\n            if(nums[i]>=last){\n                //ok,nothing need to change\n                last=nums[i];\n            }else{\n                //need change\n                //find first one larger than it\n                for(int j=nums.length-1;j>i;j--){\n                    if(nums[j]>nums[i]){\n                        //swap them \n                        int t=nums[i];\n                        nums[i]=nums[j];\n                        nums[j]=t;\n                        break;\n                    }\n                }\n                //reverse the part after i\n                reverseArr(nums,i+1,nums.length-1);\n                return;\n            }\n        }\n        reverseArr(nums,0,nums.length-1);\n    }\n}\n","usedLang":"Java"},{"fileName":"33._Search_in_Rotated_Sorted_Array","codeText":"public class Solution {\n    public int search(int[] nums, int target) {\n        \n        //use binary search\n        int l,r,mid;\n        l=0;r=nums.length-1;\n        while(l<=r){\n            mid=(l+r)/2;\n            if(target>nums[mid]){\n                if(nums[mid]>=nums[0]){\n                    //increasing so far,find right half\n                    l=mid+1;\n                }else{\n                    //this node is\n                    if(target>nums[nums.length-1]){\n                        //in the left side\n                        r=mid-1;\n                    }else{\n                        //in the right side\n                        l=mid+1;\n                    }\n                }\n            }\n            else if(target<nums[mid]){\n                if(nums[mid]<nums[0]){\n                    //decreasing in the future, find left half\n                    r=mid-1;\n                }else{\n                    //this node is\n                    if(target<nums[0]){\n                        //in the right side\n                        l=mid+1;\n                    }else{\n                        //in the right side\n                        r=mid-1;\n                    }\n                }\n            }else{\n                return mid;\n            }\n        }\n        return -1;\n    }\n    \n}\n","usedLang":"Java"},{"fileName":"34._Search_for_a_Range","codeText":"public class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        boolean getL=false;boolean getR=false;\n        int[] res={-1,-1};\n        int sl=binarySearch(nums,target,0,nums.length-1);\n        if(sl==-1){\n            return res;\n        }\n        res[0]=sl;res[1]=sl;\n        while(!getL || !getR){\n            if(res[0]>0 && nums[res[0]-1]==target){\n                res[0]=binarySearch(nums,target,0,res[0]-1);\n            }else if((res[0]>0 && nums[res[0]-1]!=target)||res[0]==0){\n                getL=true;\n            }\n            if(res[1]<nums.length-1 && nums[res[1]+1]==target){\n                res[1]=binarySearch(nums,target,res[1]+1,nums.length-1);\n            }else if((res[1]<nums.length-1 && nums[res[1]+1]!=target)||res[1]==nums.length-1){\n                getR=true;\n            }\n        }\n        return res;\n    }\n    public int binarySearch(int[] nums, int target, int s, int e){\n        //if find target in s...e, return index\n        //else return -1\n        int l=s;int r=e;int mid=(l+r)/2;\n        while(l<=r){\n            mid=(l+r)/2;\n            if(nums[mid]==target){\n                return mid;\n            }else if(nums[mid]<target){\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return -1;\n    }\n}\n","usedLang":"Java"},{"fileName":"35._Search_Insert_Position","codeText":"public class Solution {\n    public int searchInsert(int[] nums, int target) {\n        if(nums.length==0)return 0;\n        if(target<nums[0])return 0;\n        else if(target>nums[nums.length-1])return nums.length;\n        int l=0;int r=nums.length-1;\n        int res=0;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(target==nums[mid])return mid;\n            else if(nums[mid]<target){\n                l=mid+1;\n            }else{\n                r=mid-1;\n                res=mid;\n            }\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"36._Valid_Sudoku","codeText":"public class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        for(int i=0;i<9;i++){\n            for(int j=0;j<9;j++){\n                if(board[i][j]!='.'){\n                    if(checkRow(board,i,j)&&checkCol(board,i,j)&&checkBlock(board,i,j))continue;\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    private boolean checkRow(char[][] board,int x, int y){\n        for(int i=0;i<9;i++){\n            if(i==x)continue;\n            if(board[x][y]==board[i][y])return false;\n        }\n        return true;    \n    }\n    private boolean checkCol(char[][] board,int x,int y){\n        for(int i=0;i<9;i++){\n            if(i==y)continue;\n            if(board[x][y]==board[x][i])return false;\n        }\n        return true;\n    }\n    private boolean checkBlock(char[][] board,int x,int y){\n        int rx=(int)(x/3)*3;\n        int ry=(int)(y/3)*3;\n        for(int i=0;i<3;i++){\n            for(int j=0;j<3;j++){\n                if(rx+i==x && ry+j==y)continue;\n                if(board[rx+i][ry+j]==board[x][y])return false;\n            }\n        }\n        return true;\n    }\n}\n","usedLang":"Java"},{"fileName":"38._Count_and_Say","codeText":"public class Solution {\n    public String countAndSay(int n) {\n        if(n==1 || n==0){\n            return \"1\";\n        }\n        return countStr(countAndSay(n-1));\n    }\n    //pre: str length is larger than 0\n    private String countStr(String str){\n        int count=1;\n        char last=str.charAt(0);\n        StringBuilder res=new StringBuilder();\n        for(int i=1;i<str.length();i++){\n            char curr=str.charAt(i);\n            if(curr==last){\n                count++;\n            }else{\n                res.append(count);\n                res.append(last);\n                count=1;last=curr;\n            }\n        }\n        res.append(count);\n        res.append(last);\n        return res.toString();\n    }\n    \n}\n","usedLang":"Java"},{"fileName":"39._Combination_Sum","codeText":"public class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        return helper(candidates,0,target);\n    }\n    private List<List<Integer>> helper(int[] nums,int from, int target){\n        List<List<Integer>> res=new LinkedList<List<Integer>>();\n        for(int i=from;i<nums.length;i++){\n            if(nums[i]==target){\n                List<Integer> temp=new LinkedList<Integer>();\n                temp.add(target);\n                res.add(temp);\n            }else if(nums[i]<target){\n                List<List<Integer>> tres= helper(nums,i, target-nums[i]);\n                for(List<Integer> l:tres){\n                    l.add(0,nums[i]);\n                    res.add(l);\n                }\n            }\n            \n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"40._Combination_Sum_II","codeText":"public class Solution {\n    List<List<Integer>> res;\n    HashSet<String> sol;\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        res=new ArrayList<List<Integer>>();\n        Arrays.sort(candidates);\n        sol=new HashSet<String>();\n        combinationHelper(candidates,0,new ArrayList<Integer>(),target);\n        return res;\n    }\n    //pred: sorted nums\n    private void combinationHelper(int[] nums,int from, List<Integer> pre,int target){\n        if(target==0){\n            if(pre.size()!=0)\n                res.add(pre);\n            return;\n        }\n        if(from>=nums.length)return;\n        if(nums[from]>target)return;//no possible answers\n        //choose the 'from' digit\n        if(nums[from]<=target){\n            ArrayList<Integer> tt=new ArrayList<Integer>(pre);\n            //check dups\n            tt.add(nums[from]);\n            StringBuilder sb=new StringBuilder();\n            for(int ii:tt){\n                sb.append(ii);\n                sb.append(' ');\n            }\n            String s=sb.toString();\n            if(!sol.contains(s)){\n                combinationHelper(nums,from+1,tt,target-nums[from]);\n                sol.add(s);\n            }\n        }\n        //not choose that digit\n        ArrayList<Integer> t=new ArrayList<Integer>(pre);\n        combinationHelper(nums,from+1,t,target);\n        \n        \n        \n    }\n}\n","usedLang":"Java"},{"fileName":"41._First_Missing_Positive","codeText":"public class Solution {\n    public int firstMissingPositive(int[] nums) {\n    if(nums==null || nums.length==0)return 1;\n    int last=nums.length;\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]>0 && nums[i]<=nums.length && nums[i]!=i+1){\n            int t=nums[i];\n            if(nums[t-1]==nums[i]){continue;}\n            nums[i]=nums[t-1];\n            nums[t-1]=t;\n            i--;\n        }\n    }\n    for(int i=0;i<nums.length;i++){\n        if(nums[i]==i+1)continue;\n        return i+1;\n    }\n    return nums.length+1;\n}\n}\n","usedLang":"Java"},{"fileName":"42._Trapping_Rain_Water","codeText":"public class Solution {\n    public int trap(int[] height) {\n        if(height.length<=2)return 0;\n        int lastMax=0;\n        int res=0;\n        int tmp=0;\n        for(int i=0;i<height.length;i++){\n            if(height[i]<lastMax){\n                tmp+=lastMax-height[i];\n            }else{\n                res+=tmp;\n                tmp=0;\n                lastMax=height[i];\n            }\n        }\n        int rightMax=0;tmp=0;\n        for(int i=height.length-1;i>=0;i--){\n            if(height[i]<rightMax){\n                tmp+=rightMax-height[i];\n            }else{\n                //no fence\n                res+=tmp;\n                tmp=0;\n                rightMax=height[i];\n                if(rightMax==lastMax)return res;\n            }\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"45._Jump_Game_II","codeText":"public class Solution {\n    public int jump(int[] nums) {\n        if(nums.length<=1)return 0;\n        int [] canGo=new int[nums.length];\n        for(int i=0;i<nums.length;i++){\n            canGo[i]=nums[i]+i;\n            if(canGo[i]>nums.length-1)canGo[i]=nums.length-1;\n        }\n        int res=0;\n        int curr=0;\n        //every time find largest nex one \n        while(curr<nums.length-1){\n            //need jump\n            int max=0;\n            int index=0;\n            for(int i=curr+1;i<=canGo[curr] && i<=nums.length-1;i++){\n                if(canGo[i]>=max){\n                    max=canGo[i];\n                    index=i;\n                }\n            }\n            curr=index;\n            res++;\n            \n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"46._Permutations","codeText":"public class Solution {\n    private List<List<Integer>> res;\n    private int count;\n    public List<List<Integer>> permute(int[] nums) {\n        boolean[] used=new boolean[nums.length];\n        count=0;\n        res=new ArrayList<List<Integer>>();\n        Stack<Integer> curr=new Stack<Integer>();\n        for(int i=0;i<nums.length;i++){\n            permuteHelper(nums,used,i,curr);\n        }\n        return res;\n    }\n    \n    private void permuteHelper(int[] nums,boolean[] used,int v,Stack<Integer> curr){\n        curr.push(nums[v]);\n        used[v]=true;\n        count++;\n        if(count==nums.length){\n            res.add(new ArrayList<Integer>(curr));\n        }else{\n            for(int i=0;i<nums.length;i++){\n                if(!used[i]){\n                    permuteHelper(nums,used,i,curr);\n                }\n            }\n        }\n        curr.pop();\n        used[v]=false;\n        count--;\n    }\n}\n","usedLang":"Java"},{"fileName":"47._Permutations_II","codeText":"public class Solution {\n    private void reverseArr(int[] nums, int l, int r){\n        while(l<r){\n            int t=nums[r];\n            nums[r]=nums[l];\n            nums[l]=t;\n            l++;r--;\n        }\n    }\n    public boolean nextPermutation(int[] nums) {\n        if(nums.length<=1)return true;\n        int last=nums[nums.length-1];\n        for(int i=nums.length-2;i>=0;i--){\n            if(nums[i]>=last){\n                //ok,nothing need to change\n                last=nums[i];\n            }else{\n                //need change\n                //find first one larger than it\n                for(int j=nums.length-1;j>i;j--){\n                    if(nums[j]>nums[i]){\n                        //swap them \n                        int t=nums[i];\n                        nums[i]=nums[j];\n                        nums[j]=t;\n                        break;\n                    }\n                }\n                //reverse the part after i\n                reverseArr(nums,i+1,nums.length-1);\n                return false;\n            }\n        }\n        reverseArr(nums,0,nums.length-1);\n        return true;\n    }\n    private List<Integer> getList(int[] nums){\n        List<Integer> res=new ArrayList<Integer>();\n        for(int i:nums){\n            res.add(i);\n        }\n        return res;\n    }\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        ArrayList<List<Integer>> res= new ArrayList<List<Integer>>();\n        if(nums.length<1)return res;\n        Arrays.sort(nums);\n        res.add(getList(nums));\n        while(!nextPermutation(nums)){\n            res.add(getList(nums));\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"48._Rotate_Image","codeText":"public class Solution {\n    private void rotateOuterCycle(int[][] matrix, int l,int r){\n        if(l>=r )return;\n        for(int i=0;i<r-l;i++){\n            int temp=matrix[l][l+i];\n            matrix[l][l+i]=matrix[r-i][l];\n            matrix[r-i][l]=matrix[r][r-i];\n            matrix[r][r-i]=matrix[l+i][r];\n            matrix[l+i][r]=temp;\n        }\n    }\n    public void rotate(int[][] matrix) {\n        int n=matrix.length;\n        int low=0;\n        int high=n-1;\n        while(n>0){\n            rotateOuterCycle(matrix,low++,high--);\n            n--;\n        }\n    }\n}\n","usedLang":"Java"},{"fileName":"49._Group_Anagrams","codeText":"public class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        List<List<String>> res=new ArrayList<List<String>>();\n        HashMap<Integer,List<String>> map=new HashMap<Integer,List<String>>();\n        int maxLen=0;\n        for(String str:strs){\n            if(str.length()>maxLen)maxLen=str.length();\n        }\n        for(String str:strs){\n            long key=1;\n            \n            for(int i=0;i<str.length();i++){\n                int n=str.charAt(i)-'a';\n                key=(key*(n*n+n+41))%Integer.MAX_VALUE;\n            }\n            int tkey=(int)key;\n            if(map.containsKey(tkey)){\n                map.get(tkey).add(str);\n            }\n            else{\n                List<String> list=new ArrayList<String>();\n                list.add(str);\n                map.put(tkey,list);\n                res.add(list);\n            }\n            \n            \n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"50._Pow(x,_n)","codeText":"public class Solution {\n    public double myPow(double x, int n) {\n        if(x==1)return 1;\n        if(n==1)return x;\n        if(n==0)return 1;\n        if(n<0 && x!=0) return myPow(1./x, -(n+1))*(1/x);\n        int d=n/2;\n        double res=myPow(x,d);\n        if(n%2==1)\n        return res*res*x;\n        else return res*res;\n    }\n}\n","usedLang":"Java"},{"fileName":"53._Maximum_Subarray","codeText":"public class Solution {\n    public int maxSubArray(int[] nums) {\n        if(nums.length==0)return 0;\n        int[] best =new int[nums.length];\n        best[0]=nums[0];\n        int max=nums[0];\n        for(int i=1;i<nums.length;i++){\n            if(best[i-1]>0){\n                best[i]=best[i-1]+nums[i];\n            }else{\n                best[i]=nums[i];\n            }\n            if(best[i]>max){\n                max=best[i];\n            }\n        }\n        return max;\n    }\n}\n","usedLang":"Java"},{"fileName":"54._Spiral_Matrix","codeText":"public class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        ArrayList<Integer> res=new ArrayList<Integer>();\n        if(matrix.length==0) return res;\n        boolean [][] used=new boolean[matrix.length][matrix[0].length];\n        dfs(matrix,res,used,0,0,0);\n        return res;\n    }\n    private void dfs(int [][] matrix,ArrayList<Integer> res,boolean[][] used,int x,int y,int dir){\n        if(x<0 || x>=matrix.length)return ;\n        if(y<0 || y>=matrix[x].length)return ;\n        if(used[x][y])return ;\n        used[x][y]=true;\n        res.add(matrix[x][y]);\n        switch(dir){\n        case 0:\n            dfs(matrix,res,used,x,y+1,0);break;\n        case 1:\n            dfs(matrix,res,used,x+1,y,1);break;\n        case 2:\n            dfs(matrix,res,used,x,y-1,2);break;\n        case 3:\n            dfs(matrix,res,used,x-1,y,3);break;\n        }\n        //right\n        dfs(matrix,res,used,x,y+1,0);\n        //down\n        dfs(matrix,res,used,x+1,y,1);\n        //left\n        dfs(matrix,res,used,x,y-1,2);\n        //up\n        dfs(matrix,res,used,x-1,y,3);\n       \n    }\n}\n","usedLang":"Java"},{"fileName":"55._Jump_Game","codeText":"public class Solution {\n    public boolean canJump(int[] nums) {\n        if(nums.length<=1)return true;\n        boolean[] canReach=new boolean[nums.length];\n        canReach[nums.length-1]=true;\n        int comeHere=nums.length-1;\n        for(int i=nums.length-2;i>=0;i--){\n            if(nums[i]+i>=comeHere){\n                canReach[i]=true;\n                comeHere=i;\n            }\n        }\n        return canReach[0];\n    }\n}\n","usedLang":"Java"},{"fileName":"56._Merge_Intervals","codeText":"/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\npublic class Solution {\n    public List<Interval> merge(List<Interval> intervals) {\n        List<Interval> res=new ArrayList<Interval>();\n        if(intervals.size()==0)return res;\n        Collections.sort(intervals,new Comparator<Interval>(){public int compare(Interval a,Interval b){return a.start-b.start\n            ;}});\n        Interval curr=intervals.get(0);\n        res.add(curr);\n        for(int i=1;i<intervals.size();i++){\n            if(intervals.get(i).start<=curr.end){\n                if(intervals.get(i).end>curr.end){\n                    curr.end=intervals.get(i).end;\n                }\n            }else{\n                curr=intervals.get(i);\n                res.add(curr);\n            }\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"57._Insert_Interval","codeText":"/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\n \npublic class Solution {\n    \n    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {\n        //now intervals are all disjoint.\n        List<Interval> res=new ArrayList<Interval> ();\n        int start=newInterval.start;\n        int end=newInterval.end;\n        res.add(newInterval);\n        for(Interval curr:intervals){\n            if(curr.end<newInterval.start || curr.start>newInterval.end){\n                //not overlap, add into res\n                res.add(curr);\n            }else{\n                //overlap, get the final interval\n                if(curr.end>end){\n                    end=curr.end;\n                }\n                if(curr.start<start){\n                    start=curr.start;\n                }\n            }\n        }\n        //make changes of start & end into res's first element\n        res.set(0,new Interval(start,end));\n        //shift it into the right place\n        int i=1;\n        while(i<res.size() && start>res.get(i).start){\n            //swap them(i-1 and i)\n            Interval t=res.get(i-1);\n            res.set(i-1,res.get(i));\n            res.set(i,t);\n            i++;\n        }\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"58._Length_of_Last_Word","codeText":"public class Solution {\n    public int lengthOfLastWord(String s) {\n        s=s.trim();\n        if(s.length()==0)return 0;\n        int len=0;\n        for( int i=s.length()-1;i>=0;i--){\n            if(s.charAt(i)==' ')return len;\n            else len++;\n        }\n        return len;\n    }\n}\n","usedLang":"Java"},{"fileName":"59._Spiral_Matrix_II","codeText":"public class Solution {\n    public int[][] generateMatrix(int n) {\n        if(n<0)return null;\n        int[][] res=new int[n][n];\n        int count=0;\n        int x=0;\n        int y=-1;\n        int last_d=0;\n        while(count!=n*n){\n            //search according to last direction\n            switch(last_d){\n                case 1:\n                    if(x+1>=n || res[x+1][y]!=0){\n                        last_d++;last_d=last_d%4;\n                    }else{\n                        count++;\n                        res[x+1][y]=count;x++;\n                    }\n                    break;\n                case 0:\n                    if(y+1>=n || res[x][y+1]!=0){\n                        last_d++;last_d=last_d%4;\n                    }else{\n                        count++;\n                        res[x][y+1]=count;y++;\n                    }\n                    break;\n                case 3:\n                    if(x-1<0 || res[x-1][y]!=0){\n                        last_d++;last_d=last_d%4;\n                    }else{\n                        count++;\n                        res[x-1][y]=count;x--;\n                    }\n                    break;\n                case 2:\n                    if(y-1<0 || res[x][y-1]!=0){\n                        last_d++;last_d=last_d%4;\n                    }else{\n                        count++;\n                        res[x][y-1]=count;y--;\n                    }\n                    break;\n            }\n        }\n        return res;\n        \n    }\n}\n","usedLang":"Java"},{"fileName":"60._Permutation_Sequence","codeText":"public class Solution {\n    public String getPermutation(int n, int k) {\n        if(n==0) return \"\";\n        if(n==1) return \"1\";\n        k--;\n        int[] perm=new int[n+1];\n        boolean[] using=new boolean[n+1];\n        perm[0]=1;\n        \n        for(int i=1;i<=n;i++){\n            perm[i]=i*perm[i-1];\n        }\n        if(k<0) k=(k%perm[n]+perm[n])%perm[n];\n        while(k>perm[n]) k=k%perm[n];\n        StringBuilder res=new StringBuilder();\n        int base=n-1;\n        while(k>0){\n            int r=k/perm[base]+1;\n            //find the digit, and use it\n            for(int i=1,count=0;i<=n && count!=r;i++){\n                if(using[i])continue;\n                count++;\n                if(count==r){\n                    using[i]=true;\n                    res.append(i);\n                    break;\n                }\n            }\n            //update k\n            k=k%perm[base];\n            base--;\n        }\n        //last digit\n        for(int i=1;i<=n;i++) if(!using[i])res.append(i);\n        return res.toString();\n    }\n}\n","usedLang":"Java"},{"fileName":"61._Rotate_List","codeText":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head==null || head.next==null)return head;\n        ListNode p=head;\n        int count=1;\n        while(p.next!=null){\n            count++;p=p.next;\n        }\n        ListNode last=p;\n        k=k%count;\n        if(k==0) return head;\n        int index=1;\n        p=head;\n        while(index!=count-k){\n            p=p.next;\n            index++;\n        }\n        ListNode res=p.next;p.next=null;last.next=head;\n        return res;\n    }\n}\n","usedLang":"Java"},{"fileName":"62._Unique_Paths","codeText":"\n","usedLang":"Java"},{"fileName":"65._Valid_Number","codeText":"\n","usedLang":"Java"}]